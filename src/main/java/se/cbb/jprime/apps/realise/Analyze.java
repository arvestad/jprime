package se.cbb.jprime.apps.realise;

import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import org.apache.commons.lang3.StringUtils;
import se.cbb.jprime.apps.JPrIMEApp;
import se.cbb.jprime.io.JCommanderUsageWrapper;
import se.cbb.jprime.io.NewickIOException;
import se.cbb.jprime.io.NewickRBTreeSamples;
import se.cbb.jprime.io.NewickTree;
import se.cbb.jprime.io.NewickTreeReader;
import se.cbb.jprime.io.NewickTreeWriter;
import se.cbb.jprime.io.PrIMENewickTree;
import se.cbb.jprime.io.PrIMENewickTreeReader;
import se.cbb.jprime.io.SampleNewickTree;
import se.cbb.jprime.io.SampleWriter;
import se.cbb.jprime.io.UnparsedRealisation;
import se.cbb.jprime.misc.Pair;
import se.cbb.jprime.misc.IntPair;
import se.cbb.jprime.misc.Triple;
import se.cbb.jprime.topology.BooleanMap;
import se.cbb.jprime.topology.NamesMap;
import se.cbb.jprime.topology.RBTree;
import se.cbb.jprime.topology.RBTreeEpochDiscretiser;
import se.cbb.jprime.topology.RootedBifurcatingTree;
import se.cbb.jprime.topology.TimesMap;
import se.cbb.jprime.topology.TopologyException;

import com.beust.jcommander.JCommander;

/**
 * Analyzes the realisations files generated by PrIME-DLRS,
 * 
 * @author Joel Sj√∂strand.
 * @author Owais Mahmudi.
 */
public class Analyze implements JPrIMEApp {
	
	@Override
	public String getAppName() {
		return "Analyze";
	}
	
	@Override
	public void main(String[] args) {
		BufferedWriter info = null;

		try {
			
			// ================ PARSE USER OPTIONS AND ARGUMENTS ================
			
			Parameters params = new Parameters();
			JCommander jc = new JCommander(params, args);
			if (args.length == 0 || params.help) {
				StringBuilder sb = new StringBuilder(65536);
				sb.append(
						"================================================================================\n" +
						"JPrIME-Analyze analyses the realization files generated by the realisation samp-\n" +
						"ler of PrIME-DLRS.  															 \n" +
						"     																			 \n" +
						"================================================================================\n");
				sb.append("Usage:\n" +
						"    java -jar jprime-X.Y.Z.jar Analyze [options] <args>\n");
				JCommanderUsageWrapper.getUnsortedUsage(jc, params, sb);
				System.out.println(sb.toString());
				return;
			}
			
			// ================ READ AND CREATE ALL PARAMETERS ================
			
			// MCMC chain output and auxiliary info.
			SampleWriter sampler = ParameterParser.getOut(params);
			info = ParameterParser.getInfo(params);
		    boolean mapgenetreefound=false;
		    	    
                    boolean trim=false;
                    if(params.synthetic) trim=true;
		    Triple<RBTree, NamesMap, TimesMap> sNamesTimes = ParameterParser.getHostTree(params, info, trim);
		    
		    
		    if(params.inmcmcfile != null)
		    {
			// Read the MCMC file
		    	File fmcmc = new File(params.inmcmcfile); 
		    	NewickRBTreeSamples trees = NewickRBTreeSamples.readTreesWithoutLengths(fmcmc, true, 1, Double.parseDouble(params.guestTreeSetBurninProp), 0.01);
		    	NamesMap samplesNamesMap = trees.getTemplateNamesMap();
                        
		    	RBTreeEpochDiscretiser dtimes = ParameterParser.getDiscretizer(params, sNamesTimes.first, sNamesTimes.second, sNamesTimes.third, trees.getTree(0));
		    	if(params.synthetic)
		    	{
		    		if(params.inmcmcfile != null && params.synthetic==true)
		    		{

		    			// Checks if the MAP gene tree is equal to true gene tree
		    			if(params.files.get(0) != null)
		    			{
		    				File truetree = new File(params.files.get(0));
		    				Scanner sct = new Scanner(truetree);
		    				String realisation = sct.nextLine();
		    				String regex = "ID=(\\d)* ";
		    				realisation=realisation.replaceAll(regex, "");
		    				int noOfTrueTransfers=StringUtils.countMatches(realisation, "Transfer");
		    				Realisation trueReal = UnparsedRealisation.parseRealisation(realisation);
		    				NamesMap TrueNamesMap = trueReal.getNamesMap();
		    				String realis = SampleNewickTree.toString(trueReal.getTree(), trueReal.getNamesMap(), null);						
		    				
		    				if( compareTrees(trees.getTree(0), samplesNamesMap, (RBTree) trueReal.getTree(), TrueNamesMap) )
		    				{
		    					mapgenetreefound = true;
		    					Scanner sc = new Scanner(fmcmc);
		    					if(sc.hasNextLine()){
		    						sc.nextLine(); 
		    					}

		    					double burnin = Double.parseDouble(params.guestTreeSetBurninProp);
		    					int totalTreesAfterBurnin=trees.getTotalTreeCount();
		    					int totalsamples = countLines(params.inmcmcfile)-1;
		    					//							int totalTrees= 10000;
		    					int treesToSkip = totalsamples - totalTreesAfterBurnin;
		    					int countOfMapSamples=0;
		    					int correctNoOfTransfers=0;
		    					int current_sample=0;
		    					int VAR=6;
		    					int[] cmpRealized = new int[VAR];
		    					List<List<Double>> distances = new ArrayList<List<Double>>();
		    					int[] cmpttl = new int[VAR];
		    					for(int coun=0; coun<VAR; coun++)
		    						cmpRealized[coun]=0;

		    					for(int coun=0; coun<VAR-1; coun++)
		    						cmpttl[coun]=0;


		    					while (sc.hasNextLine()) {
		    						current_sample++;
		    						//StringUtils.countMatches(sample_realisation, "Transfer");
		    						String line = sc.nextLine();
		    						int sampleNo = Integer.parseInt(line.split("\t")[0]);
		    						String sample_realisation = line.split("\t")[10];
		    						String genetree = line.split("\t")[9];
		    						NewickTree sampledtree= NewickTreeReader.readTree(genetree, true);

		    						Realisation sampledRealisation = UnparsedRealisation.parseRealisation(sample_realisation, TrueNamesMap);

		    						if(current_sample >= treesToSkip){
		    							if(compareTrees( sampledtree, samplesNamesMap, (RBTree) trueReal.getTree(), TrueNamesMap))
		    							{
		    								int noOfTransfersInSample=StringUtils.countMatches(sample_realisation, "Transfer");
		    								if(noOfTransfersInSample==noOfTrueTransfers)
		    									correctNoOfTransfers++;						// Correct Number of Transfers Inferred

		    								countOfMapSamples++;
		    								int[] cmpRealized1 = compareRealisations(trueReal, sampledRealisation, VAR, distances, dtimes);
		    								for(int coun=0; coun<VAR; coun++)
		    									cmpRealized[coun]+=cmpRealized1[coun];

		    							}
		    						}
		    					}

		    					

		    					cmpRealized[5]=correctNoOfTransfers;
		    					//System.out.println("Correct number of transfers were inferred " + correctNoOfTransfers + "/" + countOfMapSamples);
		    					//	System.out.printf("%3.4s \t %3f \t %3d \t %3d \t %3d \t %3d \t %3d \t %3d\n", familyname, countOfMapSamples/(float)(current_sample-treesToSkip), countOfMapSamples, correctGeneTreeEdges, correctEpochs, correctFroms, correctTos, correctFromAndTos);

		    					//possible correct G edges
		    					cmpttl[0]=trees.getTreeCount(0)*noOfTrueTransfers;
		    					//possible correct epochs
		    					cmpttl[1]=cmpRealized[0];			// count of correct gene tree edges inferred
		    					//possible froms
		    					cmpttl[2]=cmpRealized[0];			// count of correct --- inferred
		    					//possible tos
		    					cmpttl[3]=cmpRealized[0];			// count of correct --- inferred
		    					//possible correct froms-tos
		    					cmpttl[4]=cmpRealized[0];			// count of correct --- inferred
		    					cmpttl[5]=trees.getTreeCount(0);	// count of map G tree samples

		    					Double sumavg=0.0, summax=0.0, maxavg=0.0, maxmax=0.0, avgavg=0.0, avgmax=0.0;
		    					Double sumAvgTimes=0.0, avgAvgTimes=0.0, maxAvgTimes=0.0, sumMaxTimes=0.0, avgMaxTimes=0.0, maxMaxTimes=0.0;
		    					for(int i=0; i<distances.size(); i++)
		    					{
		    						sumavg += distances.get(i).get(0);
		    						summax += distances.get(i).get(1);
		    						sumAvgTimes += distances.get(i).get(2);
		    						sumMaxTimes += distances.get(i).get(3);

		    						if(maxavg < distances.get(i).get(0))
		    							maxavg = distances.get(i).get(0);
		    						if(maxmax < distances.get(i).get(1))
		    							maxmax = distances.get(i).get(1);
		    						if(maxAvgTimes < distances.get(i).get(2))
		    							maxAvgTimes = distances.get(i).get(2);
		    						if(maxMaxTimes < distances.get(i).get(3))
		    							maxMaxTimes = distances.get(i).get(3);
		    					}

		    					avgavg = sumavg / distances.size();
		    					avgmax = summax / distances.size();
		    					avgAvgTimes = sumAvgTimes/distances.size();
		    					avgMaxTimes = sumMaxTimes/distances.size();

		    					//							System.out.println("TopAvg(Avg)"+ ", TopAvg(Max) " +  ", TopMax(Avg) " +  " TopMax(Max) " +  ", TempAvg(Avg) "+  ", TempAvg(Max) " +  ", TempMax(Avg) " +  " TempMax(Max) ");
		    					//							System.out.println(avgavg +" , "+ avgmax +" , "+ maxavg +" , "+ maxmax +" , "+ avgAvgTimes +" , "+ avgMaxTimes +" , "+ maxAvgTimes +" , "+ maxMaxTimes);

		    					if(params.transferstatsfile!=null)
		    					{
		    						PrintWriter trstats = new PrintWriter(new BufferedWriter(new FileWriter(params.transferstatsfile, true)));
		    						trstats.println("Correct GT edge, correct epoch, correct-from-lineage, correct-to-lineage, correct-from-to-lineage, correct-No-of-transfers: \n" + cmpRealized[0] + ", " + cmpRealized[1] + ", " + cmpRealized[2] + ", " + cmpRealized[3] + ", " + cmpRealized[4] + ", " + cmpRealized[5]);
		    						trstats.println(cmpttl[0] + ", " + cmpttl[1] + ", " + cmpttl[2] + ", " + cmpttl[3] + ", " + cmpttl[4] + ", " + cmpttl[5]);
		    						trstats.println(cmpRealized[0]/(double)cmpttl[0] + ", " + cmpRealized[1]/(double)cmpttl[1] + ", " + cmpRealized[2]/(double)cmpttl[2] + ", " + cmpRealized[3]/(double)cmpttl[3] + ", " + cmpRealized[4]/(double)cmpttl[4] + ", " + cmpRealized[5]/(double)cmpttl[5]);
		    						trstats.println("TopAvg(Avg)"+ ", TopAvg(Max) " +  ", TopMax(Avg)" +  ", TopMax(Max)" +  ", TempAvg(Avg)"+  ", TempAvg(Max)" +  ", TempMax(Avg)," +  " TempMax(Max) ");
		    						trstats.println(avgavg +", "+ avgmax +", "+ maxavg +", "+ maxmax +", "+ avgAvgTimes +", "+ avgMaxTimes +", "+ maxAvgTimes +", "+ maxMaxTimes);
		    						//								trstats.println("Correct number of transfers were inferred " + correctNoOfTransfers + "/" + countOfMapSamples);
		    						//								trstats.printf("%3s \t %3f \t %3d \t %3d \t %3d \t %3d \t %3d \t %3d\n", familyname, countOfMapSamples/(float)(current_sample-treesToSkip), countOfMapSamples, correctGeneTreeEdges, correctEpochs, correctFroms, correctTos, correctFromAndTos);
		    						trstats.close();
		    					}

		    				}
		    			}
		    		}
		    	}else
                        {
                            // Biological data analysis
                            // Statistics about the gene tree
                            mapgenetreefound = true;
                            Scanner sc = new Scanner(fmcmc);
                            if(sc.hasNextLine()){
                                    sc.nextLine(); 
                            }
                            double burnin = Double.parseDouble(params.guestTreeSetBurninProp);
                            
                            int treecount2=trees.getTotalTreeCount();
                            int treecount1=trees.getNoOfTrees();
                            List<vertex_stats> itemList = new ArrayList<vertex_stats>();
                            
                            int totalsamples = countLines(params.inmcmcfile)-1;
                            int treesToSkip = (int)(burnin*totalsamples);
                            int current_sample=0;
                            

                            while (sc.hasNextLine()) {
                                    current_sample++;
                                    //StringUtils.countMatches(sample_realisation, "Transfer");
                                    String line = sc.nextLine();
                                    int sampleNo = Integer.parseInt(line.split("\t")[0]);
                                    String sample_realisation = line.split("\t")[12];
                                    String genetree = line.split("\t")[9];
                                    NewickTree sampledtree= NewickTreeReader.readTree(genetree, true);

                                    Realisation sampledRealisation = UnparsedRealisation.parseRealisation(sample_realisation, samplesNamesMap);

                                    if(current_sample > treesToSkip){
                                        int noOfTransfersInSample=StringUtils.countMatches(sample_realisation, "Transfer");
                                        List<Integer> vertices =sampledRealisation.getTree().getTopologicalOrdering();
                                        BooleanMap transfersMap = sampledRealisation.getTransfer();
                                        BooleanMap duplicationsMap = sampledRealisation.getDuplication();

                                        int size=vertices.size();
                                        for(int i=0; i<size; i++){

//                                                        System.out.println("vertex no: " + i + " :    " +sampledRealisation.getNameOfLeaves(i));
                                            if(!sampledRealisation.getTree().isLeaf(i))
                                            {
                                                String leavesOfVertexI=sampledRealisation.getNameOfLeaves(i).toString(); 
                                                String leavesOfLC=sampledRealisation.getNameOfLeaves(sampledRealisation.getTree().getLeftChild(i)).toString(); 
                                                String leavesOfRC=sampledRealisation.getNameOfLeaves(sampledRealisation.getTree().getRightChild(i)).toString(); 
                                                String parentLeaves="all";
                                                if(!sampledRealisation.getTree().isRoot(i))
                                                    parentLeaves=sampledRealisation.getNameOfLeaves(sampledRealisation.getTree().getParent(i)).toString();
                                                //InventoryItem item = new InventoryItem("Pencil", 123456789, 1, 1.25);

                                                String s = sampledRealisation.getPlacements().get(i);
                                                String s1=s.subSequence(1, s.indexOf(','))+"";
                                                String s2=s.subSequence(s.indexOf(',')+1, s.indexOf(')'))+"";
                                                int EPOCH_NO=Integer.parseInt(s1);
                                                int DISC_PT=Integer.parseInt(s2);
                                                String parentPlacement="";
                                                int parentalEdgeOnSpeciesTree=-1;
                                                int edgeArc=Integer.parseInt(sampledRealisation.getSpeciesEdges().get(i).subSequence(1, sampledRealisation.getSpeciesEdges().get(i).indexOf(','))+"");
                                                int mappingToSpeciesTree = dtimes.getEpoch(EPOCH_NO).getArcs()[edgeArc];

                                                if(!sampledRealisation.getTree().isRoot(i)){
                                                    String sparc=sampledRealisation.getSpeciesEdges().get(sampledRealisation.getTree().getParent(i));
                                                    int spArc = Integer.parseInt(sparc.subSequence(1, sparc.indexOf(','))+"");
                                                    parentalEdgeOnSpeciesTree=dtimes.getEpoch(EPOCH_NO).getArcs()[spArc];
                                                    parentPlacement = sampledRealisation.getPlacements().get(sampledRealisation.getTree().getParent(i));

                                                }else
                                                {
                                                    parentPlacement = "stem-root";
                                                    parentalEdgeOnSpeciesTree=-1;
                                                }
                                                double time=dtimes.getTime(EPOCH_NO, DISC_PT);
                                                if(sampledRealisation.getFromTos().get(i)!=null){
                                                    String s11 = sampledRealisation.getFromTos().get(i);
                                                    String s111="", s222="";
                                                    if(s11 != null)
                                                    {
                                                        s111= s11.subSequence(1, s11.indexOf(','))+"";
                                                        s11 = s11.subSequence(s11.indexOf(',')+1, s11.indexOf(')')+1)+"";
                                                        s222= s11.subSequence(0, s11.indexOf(','))+"";

                                                    }

                                                    Pair<String, Double> fromAndTo = new Pair(s111 + "->" + s222, time);
//                                                                System.out.println(sampledRealisation.toString());
                                                    vertex_stats item = new vertex_stats(leavesOfVertexI, leavesOfLC, leavesOfRC, 1, duplicationsMap.get(i)==false?0.0:1.0,
                                                            transfersMap.get(i)==false?0.0:1.0, (duplicationsMap.get(i)==false && transfersMap.get(i)==false)?1.0:0.0, fromAndTo, parentLeaves, parentalEdgeOnSpeciesTree, parentPlacement, mappingToSpeciesTree);
                                                    itemList = addItemToList(itemList, item);
                                                }else{
                                                    vertex_stats item = new vertex_stats(leavesOfVertexI, leavesOfLC, leavesOfRC, 1, duplicationsMap.get(i)==false?0.0:1.0, 
                                                            transfersMap.get(i)==false?0.0:1.0, (duplicationsMap.get(i)==false && transfersMap.get(i)==false)?1.0:0.0, parentLeaves, parentalEdgeOnSpeciesTree, parentPlacement, mappingToSpeciesTree);
                                                    itemList = addItemToList(itemList, item);
                                                }
                                            }
                                        }
                                    }
                            }
                            
                            PrintWriter trstats = new PrintWriter(new BufferedWriter(new FileWriter(params.transferstatsfile, true)));
                            double THRESHOLD_VERTEX=0.8, THRESHOLD_TRANS=0.1, THRESHOLD_SPEC=0.1;
                            
                            trstats.println("Threshold for Vertex Support = "+ THRESHOLD_VERTEX + "\nThreshold for Transfer Support =  "+ THRESHOLD_TRANS +"\nThreshold for Speciation Support =  "+ THRESHOLD_SPEC);
                            for (int j=0; j < itemList.size(); j++)
                            {
                                itemList.get(j).output(trstats, totalsamples-treesToSkip, THRESHOLD_VERTEX, THRESHOLD_TRANS, THRESHOLD_SPEC, j);
                            }
                            trstats.close();
                        }
		    }
		} catch (Exception e) {
		    String msg = e.getMessage();
			System.err.print("\nERROR: " + msg + "\n\nUse option -h or --help to show usage.\nSee .info file for more information.\n");
			if (info != null) {
				Writer w = new StringWriter();
			    PrintWriter pw = new PrintWriter(w);
 			    e.printStackTrace(pw);
				try {
					info.write("# Run failed. Reason:\n" + w.toString());
					info.close();
					pw.close();
					w.close();
				} catch (IOException f) {
				}
			}
		}
	}
	
	/**
	 * Compare a RBTree st1 with another RBTree tt2 with the given names
	 * templates.
	 * @param st1 tree
	 * @param samplesNamesMap
	 * @param tt2 tree 
	 * @param TrueNamesMap 
	 * @throws NewickIOException 
	 * @throws TopologyException 
	 */
	private boolean compareTrees(RBTree st1, NamesMap samplesNamesMap, RBTree tt2, NamesMap TrueNamesMap) throws NewickIOException, TopologyException {
		// Function
		
		String truetree2 = tt2.toString();
		PrIMENewickTree tree2 = PrIMENewickTreeReader.readTree(truetree2, false, true);
		RBTree rbtree2 = new RBTree((NewickTree) tree2,"");

		for(int ver=0; ver < TrueNamesMap.getSize(); ver++)
		{
			if(!rbtree2.isLeaf(ver))
				TrueNamesMap.set(ver, null);
		}
		
		String tr1=NewickTreeWriter.write(st1, samplesNamesMap, true);
		String tr2=NewickTreeWriter.write(rbtree2, TrueNamesMap, true);	
		//Function ends
		if(tr1.toString().equalsIgnoreCase(tr2.toString()))
			return true;
		else 
			return false;
	}
	
	/**
	 * Compare a RBTree st1 with another RBTree tt2 with the given names
	 * templates.
	 * @param st1 tree
	 * @param samplesNamesMap
	 * @param tt2 tree 
	 * @param TrueNamesMap 
	 * @throws NewickIOException 
	 * @throws TopologyException 
	 */
	private boolean compareTrees(NewickTree st1, NamesMap samplesNamesMap, RBTree tt2, NamesMap TrueNamesMap) throws NewickIOException, TopologyException {
		// Function
		
		String truetree2 = tt2.toString();
		PrIMENewickTree tree2 = PrIMENewickTreeReader.readTree(truetree2, false, true);
		RBTree rbtree2 = new RBTree((NewickTree) tree2,"");
		
		for(int ver=0; ver < TrueNamesMap.getSize(); ver++)
		{
			if(!rbtree2.isLeaf(ver))
				TrueNamesMap.set(ver, null);
		}
		
		String tr1=NewickTreeWriter.write(st1);
		String tr2=NewickTreeWriter.write(rbtree2, TrueNamesMap, true);	
		//Function ends
		if(tr1.toString().equalsIgnoreCase(tr2.toString()))
			return true;
		else 
			return false;
	}	

	/**
	 * Compare two realisations for transfers on correct edges, correct lineages, and so on.. 
	 * templates.
	 * @param dtimes 
	 * @param Realisation r1
	 * @param Realisation r2
	 * @param anyother? 
	 * @throws NewickIOException 
	 * @throws TopologyException 
	 */
	private int[] compareRealisations(Realisation r1, Realisation r2, int VAR, List<List<Double>> distances, RBTreeEpochDiscretiser dtimes ) throws NewickIOException, TopologyException {
		// Function
		int[] stats = new int[VAR+1]; // Correct edges, correct epochs, correct-from, correct-to, correct-from-to .. 
		for(int i=0; i<VAR; i++ )
			stats[i]=0;
		
		
		//.\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/.
		// Computing distances (minimizing them based on the distance across possible permutations..) 
		// ./\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\../\.
		
		List<List> scoreList = new ArrayList<List>();
		int[]  nodesmap_r2to_r1 = r2.getNodeToNodeMap(r1);
		int countOfTrueTransfers=StringUtils.countMatches(r1.toString(), "Transfer");
		int x=countOfTrueTransfers;
		// testing the combinations part
		//IntMap list = ;
		List<List<Integer>> lists= new ArrayList<List<Integer>>(); 
		 int[] s = new int[x];
		 int[] arr = new int[x];
		 for(int i=0; i<x; i++)
			 s[i]=i+1;
		 permute(s,  arr, 0, lists, 0);
		 int[] scores = new int[lists.size()];
		 int minimumScore=-1, min_combination=-1, max_distance=-1;
		 double sum_times=-1, max_time=-1, time_diff=-1;
		 
		 if(countOfTrueTransfers == StringUtils.countMatches(r2.toString(),"Transfer")){
			 BooleanMap transMapr1 = r1.getTransfer();
			 BooleanMap transMapr2 = r2.getTransfer();
			 
			 int [] r1Transfers = new int[countOfTrueTransfers]; 
			 int [] r2Transfers = new int[countOfTrueTransfers];
			 int r1index=0, r2index=0;
			 for(int i=0; i<transMapr1.getSize(); i++)
			 {
				 if( transMapr1.get(i) == true){
					 r1Transfers[r1index]=i;
					 r1index=r1index+1;
				 }
				 
				 if( transMapr2.get(i) == true){
					 r2Transfers[r2index]=i;
					 r2index=r2index+1;
				 }				 
			 }
			 
			 
			 for(int i=0; i<lists.size(); i++)
			 {	// for each combination of vertices do the following:
				 ArrayList<Integer> score= new ArrayList<Integer>();
				 int pairs = lists.get(i).size() /2;
				 int totalDistance =0, max_dist=0;
				 double totalTime=0, max_t=0;;
				 for (int j=0; j< pairs*2; j+=2)
				 {	// for each pair of nodes do the following:
					 int r1node=-1, r2node=-1;
					 r1node=r1Transfers[lists.get(i).get(j)-1];
					 r2node=r2Transfers[lists.get(i).get(j+1)-1];
					 // compute distance between r1node nd r2node
					 int dist = pairDistance(r1node, r2node, r1.getTree(), r2.getTree(), nodesmap_r2to_r1);
					 String r1time = r1.getPlacements().get(r1node);
					 
					 int epochNo=Integer.parseInt(r1time.substring(1, r1time.indexOf(','))), idx=Integer.parseInt(r1time.substring(r1time.indexOf(',')+1, r1time.indexOf(')')));
					 double r1_time = dtimes.getTime(epochNo, idx);
					 
					 String r2time = r2.getPlacements().get(r2node);
					 epochNo=Integer.parseInt(r2time.substring(1, r2time.indexOf(','))); idx=Integer.parseInt(r2time.substring(r2time.indexOf(',')+1, r2time.indexOf(')')));
					 double r2_time = dtimes.getTime(epochNo, idx);
					 
					 time_diff = Math.abs(r1_time -r2_time); 
					 
					 score.add(dist);
					 if(max_dist < dist)
						 max_dist = dist;
					 if(max_t < time_diff)
						 max_t = time_diff;
					 totalDistance = totalDistance + dist;
					 totalTime=totalTime + time_diff;
				 }
				 scoreList.add(score);
				 scores[i]=totalDistance;
				 if(minimumScore > totalDistance){
					 minimumScore = totalDistance;
					 min_combination = i;
					 max_distance= max_dist;
					 sum_times=totalTime;
					 max_time = max_t;
				 }else {
					 if(minimumScore == -1){
						 minimumScore = totalDistance;
						 min_combination = i;
						 max_distance = max_dist;
						 sum_times=totalTime;
						 max_time = max_t;
					 }
				 }
			 }
		 } // If statement: ensures correct number of transfers
		 if(min_combination != -1)
		 {
			 ArrayList<Double> distance = new ArrayList<Double>();
			 
			 double average_distance= minimumScore/(double) countOfTrueTransfers;
			 double average_time= sum_times/(double) countOfTrueTransfers;			 
			 distance.add(average_distance);
			 distance.add((double) max_distance);
			 distance.add(average_time);
			 distance.add(max_time);
			 distances.add(distance);
		 }
		 //double max_distance = 
		 //
		 //	  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00 
		 //  _||__||__||__||__||__||__||__||__||__||__||__||__||__||__||__||__||__||__||__||_
		 //\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
		 
		 
		 
		int noOfVertices = r1.getTree().getNoOfVertices();
		// counts the transfer if inferred on the correct gene tree edge
		int correctTransfers=0;
		
		int correctEpochs = 0;
		for(int v=0; v < noOfVertices; v++)
		{
			List<String> r1leaves = r1.getNameOfLeaves(v);
			for (int v2=0; v2 < noOfVertices; v2++){
				List<String> r2leaves = r2.getNameOfLeaves(v2);
				
				if (r1leaves.equals(r2leaves)){
					if(r1.getTransfer().get(v) == true && r2.getTransfer().get(v2)==true){
						correctTransfers++;				// counts the transfers mapped to correct gene tree edges
						String r2str=r2.getPlacements().get(v2);
						int r2Epoch=Integer.parseInt(r2str.substring(1, r2str.indexOf(',')));
						
						String r1str=r1.getPlacements().get(v) ;
						int r1Epoch=Integer.parseInt(r1str.substring(1, r1str.indexOf(',')));

						if(r1Epoch == r2Epoch || r1Epoch != r2Epoch){
							if(r1Epoch == r2Epoch)
							correctEpochs+=1;			// counts the tranqsfers mapped to correct epochs
							String r1FromTo=r1.getFromTos().get(v);
							String r2FromTo = r2.getFromTos().get(v2);
							int r1f=0, r1t=0, r2f=0, r2t=0;
							r1f = Integer.parseInt(r1FromTo.substring(1, r1FromTo.indexOf(',')));
							r2f = Integer.parseInt(r2FromTo.substring(1, r2FromTo.indexOf(',')));
							String r1FromToRem=r1FromTo.substring(r1FromTo.indexOf(',')+1), r2FromToRem=r2FromTo.substring(r2FromTo.indexOf(',')+1);

							r1t = Integer.parseInt(r1FromToRem.substring(0, (r1FromToRem.lastIndexOf(',') == -1)?r1FromToRem.lastIndexOf(')'):r1FromToRem.lastIndexOf(',')));
							r2t = Integer.parseInt(r2FromToRem.substring(0, (r2FromToRem.lastIndexOf(',') == -1)?r2FromToRem.lastIndexOf(')'):r2FromToRem.lastIndexOf(',')));
							
							if(r1f == r2f)
								stats[2]+=1;
							if(r1t == r2t)
								stats[3]+=1;
							if(r1f == r2f && r1t==r2t)
								stats[4]+=1;
						}
					}
				}
			}
		}
		
		stats[0]=correctTransfers;
		stats[1]=correctEpochs;
		return stats;
	}
	
	public static int countLines(String filename) throws IOException {
	    InputStream is = new BufferedInputStream(new FileInputStream(filename));
	    try {
	        byte[] c = new byte[1024];
	        int count = 0;
	        int readChars = 0;
	        boolean empty = true;
	        while ((readChars = is.read(c)) != -1) {
	            empty = false;
	            for (int i = 0; i < readChars; ++i) {
	                if (c[i] == '\n') {
	                    ++count;
	                }
	            }
	        }
	        return (count == 0 && !empty) ? 1 : count;
	    } finally {
	        is.close();
	    }
	}
	
	
	void biologicalAnalysis(Realisation r1, RBTreeEpochDiscretiser dtimes, int[] epochStats)
	{
		int noOfVertices = r1.getTree().getNoOfVertices();
		for(int v=0; v < noOfVertices; v++)
		{
			if(r1.getTransfer().get(v) == true)
			{		
				String r1str=r1.getPlacements().get(v) ;
				int r1Epoch=Integer.parseInt(r1str.substring(1, r1str.indexOf(',')));
				epochStats[r1Epoch]=epochStats[r1Epoch]+1;
			}
		}
	}
	
	
	void permute(int[] s, int[] arr, int index, List<List<Integer>> lists, int itemno){
		if ( s.length == 1){
			ArrayList<Integer> list = new ArrayList<Integer>();
			arr[arr.length-1]=s[s.length-1];
			// print arr here
			for(int k=0; k<arr.length; k++){
				list.add(k+1);
				list.add(arr[k]);
			}
			lists.add(list);
			itemno=itemno+1;
//			System.out.println();
		}else
		{
			for(int i=0; i<s.length; i++)
			{
				int offset =0;
				arr[index]=s[i];
				int [] sp = new int[s.length-1];
				for (int j=0; j<s.length; j++)
				{	
					if(j!=i) 
						sp[j-offset]=s[j];	
					else
						offset=1;
				}
				permute(sp, arr, index+1, lists, itemno);
			}
		}
	}
		
	
	// Computes the distance between the pair of nodes i.e. the count of edges on the path between them
	int pairDistance(int node1, int node2, RootedBifurcatingTree tree1, RootedBifurcatingTree tree2, int[] nodesmap_r2tor1 )
	{
		node2=nodesmap_r2tor1[node2];
		List<Integer> ancestors1 = tree1.getAncestors(node1, true);
		// using the tree1 because the trees are supposed to be equal at this time, while the only problem is differnt numbering. which is solved by nodesmap
		List<Integer> ancestors2 = tree1.getAncestors(node2, true);

		int distance1=-1, distance2=-1, distance=-1;
		
		if(node1 != node2)
		{
			if(ancestors1.contains(node2) || ancestors2.contains(node1)){
				//System.out.println("Nodes exists on a single root to leaf path");
				if(ancestors1.contains(node2))
					distance=returnDistanceFromAncestor(node1, node2, tree1);
				else
					distance=returnDistanceFromAncestor(node2, node1, tree1);
			}
			else // get MRCA of two nodes
			{
				boolean found=false;
				int mrca = -1;
				for(int i=0; i<ancestors1.size(); i++)
				{
					for (int j=0; j< ancestors2.size(); j++)
					{
						if (ancestors1.get(i) == ancestors2.get(j)){
							found = true;
							mrca=ancestors1.get(i);
							
						}
						if(found) break;
					}
					if(found) break;
				}	
				// mrca found now compute the distance
				distance1 = returnDistanceFromAncestor(node1, mrca, tree1);
				distance2 = returnDistanceFromAncestor(node2, mrca, tree1);
				distance=distance1 + distance2;
			}
		}else
		{
			return(0);
		}
	
		return distance;
	}
	
	
	int returnDistanceFromAncestor(int node, int ancestor, RootedBifurcatingTree tree)
	{	// Assume ancestor is in fact ancestor of node
		int distance = 1;
		while( tree.getParent(node) != ancestor)
		{
			if(tree.getParent(node) == tree.getRoot() && tree.getRoot() != ancestor)
				// ancestor not found!
				return -1;
				
			distance+=1;
			node=tree.getParent(node);
		}
		return distance;
	}
        
        class vertex_stats { //Delcare variables below
            String p_leaves;
            String leaves;      // Descendent leaves of vertices
            String lc_leaves;   // Left child descendent leaves
            String rc_leaves;   // Right child descendent leaves
            int count;          // Number of times a vertex is repeated in the posterior
            double p_dup;       // Number of times a vertex is observed as duplication vertex
            double p_trans;     // Number of times a vertex is observed as transfer vertex
            double p_spec;      // Number of times a vertex is observed as speciation vertex
            int pEdgeInSpTree;
            String parentalPlacement;
            List<species_edge> fromTos = new ArrayList<species_edge>(); // Store the summaries of the from and to lineages..
            Pair<String, Double> fromTo;    // Store the individual vertex
            List<IntPair> speciesNodes = new ArrayList<IntPair>();

            public vertex_stats(String lvs, String lc, String rc, int cnt, double dup, double trans, double spec, Pair<String, Double> frTo, String pleaves, int pSpEdge, String parentPlacement, int mappingToSpeciesTree) { //declare variables for this class
                this.leaves = lvs;
                this.lc_leaves= lc;
                this.rc_leaves=rc;
                this.count = cnt;
                this.p_dup = dup;
                this.p_trans = trans;
                this.p_spec = spec; // will be not used perhaps
                this.fromTo = frTo;
                this.p_leaves = pleaves;
                this.pEdgeInSpTree = pSpEdge;
                this.parentalPlacement = parentPlacement;
                this.speciesNodes.add(new IntPair(mappingToSpeciesTree, 1));

            }
            
            public vertex_stats(String lvs, String lc, String rc, int cnt, double dup, double trans, double spec, String pleaves, int pSpEdge, String parentPlacement, int mappingToSpeciesTree) { //declare variables for this class
                this.leaves = lvs;
                this.lc_leaves= lc;
                this.rc_leaves=rc;
                this.count = cnt;
                this.p_dup = dup;
                this.p_trans = trans;
                this.p_spec = spec; // will be not used perhaps
                this.p_leaves = pleaves;
                this.pEdgeInSpTree = pSpEdge;
                this.parentalPlacement = parentPlacement;
                this.speciesNodes.add(new IntPair(mappingToSpeciesTree, 1));
            }
            
            public int get_vertex_freq(){   
                return count;
            }
            
            public String get_leaves(){   
                return leaves;
            }
            
            public String get_LC_leaves(){   
                return lc_leaves;
            }

            public String get_RC_leaves(){   
                return rc_leaves;
            }
            
            public double get_dup_freq(){   
                return p_dup;
            }

            public double get_trans_freq(){   
                return p_trans;
            }

            public double get_spec_freq(){   
                return p_spec;
            }

            public List<species_edge> get_fromTos(){   
                return fromTos;
            }
           
            public Pair<String, Double> get_fromTo(){   
                return fromTo;
            }           
            
            public List<IntPair> get_Sp_nodes(){   
                return speciesNodes;
            }             
            
            public void add_to_vertex_stats(String leaves, int cnt, double dup, double trans, double spec, Pair<String, Double> frTo, int mappingToSpeciesTreeEdge){
                this.count += cnt;
                this.p_dup += dup;
                this.p_trans += trans;
                this.p_spec += spec; // will be not used perhaps
                if(frTo !=null){
                    boolean flag=false;
                    for (int i=0; i<this.fromTos.size(); i++){
                        if(this.fromTos.get(i).getTransferName().contentEquals(frTo.first)){
                            this.fromTos.get(i).times.add(frTo.second);
                            flag=true;
                        }
                    }
                    if(flag==false){
                        List<Double> ld = new ArrayList<Double>();
                        ld.add(frTo.second);
                        this.fromTos.add(new species_edge(frTo.first, ld));
                    }
                }
                
                boolean flag = false;
                int i=0;
                for(i=0; i<this.speciesNodes.size(); i++){
                    if (this.speciesNodes.get(i).first == mappingToSpeciesTreeEdge){
                        this.speciesNodes.set(i, new IntPair(i,this.speciesNodes.get(i).second+1));
                        flag=true;
                        break;
                    }   
                }
                if(!flag){
                    this.speciesNodes.add(i,new IntPair(i,1));
                }
            }
            
            public void output(PrintWriter pw, int totalsamples, double threshold_vertex_support, double threshold_transfer_support, double threshold_speciation_support, int vertex_no) {
                double support = count/(double)totalsamples;
                if(support > threshold_vertex_support){
                    pw.println("---------------------------");
                    pw.println("Vertex # " + vertex_no);
                    pw.println("Leaves(vertex) = " + leaves); //print out the leaves
                    pw.println("=> Leaves(lc(vertex)) = " + this.lc_leaves); //print out the lc leaves
                    pw.println("=> Leaves(rc(vertex)) = " + this.rc_leaves); //print out the rc leaves
                    pw.println();
                    pw.println("Parent leaves = " + this.p_leaves);
                    pw.println("Parent placed on edge " + this.pEdgeInSpTree + " of species tree, with disc. pt = " + this.parentalPlacement );
                    pw.println();
                    pw.println("Freq(vertex u)    = " + count+ "\t\t" + String.format("%.4f",count/(double)totalsamples)); //print out the count
                    pw.println("Freq(u | u->dupl) = " + p_dup + "\t\t" + String.format("%.4f",p_dup/(double)count)); //print out the probability of vertex being duplication event
                    pw.println("Freq(u | u->spec) = " + p_spec + "\t\t" + String.format("%.4f",p_spec/(double)count)); //print out the probability of vertex being a speciation event
                    pw.println("Freq(u | u->tran) = " + p_trans + "\t\t" + String.format("%.4f",p_trans/(double)count)); //print out the probability of vertex being transfer event
                    pw.println();
                    pw.println("From&To in Sp. Tree \t Support \t Normalized Time \t Time in MYA");
    //                pw.println("Speciation Count = " + p_spec); //print out the probability of vertex bring speciation

                    for(int i =0; i<this.fromTos.size();i++){
                        double sum=0;
                        for(int j=0; j<this.fromTos.get(i).times.size(); j++)
                            sum+=this.fromTos.get(i).times.get(j);
                        if(this.fromTos.get(i).times.size()/+p_trans > threshold_transfer_support)
                            pw.println(this.fromTos.get(i).name  + "\t\t" + String.format("%.2f",this.fromTos.get(i).times.size()/+p_trans) + " (" + String.format("%04d",this.fromTos.get(i).times.size())+"/"+p_trans+")\t\t" +String.format("%.4f",sum/(double)this.fromTos.get(i).times.size()) + "\t\t" + String.format("%.4f",((sum/(double)this.fromTos.get(i).times.size())/1.2532527318130844)*1583.5599138815137) + " mya"); 
                   }
                    
                   pw.println();
                   int sum=0;
                   for (int i =0; i<this.speciesNodes.size(); i++){
                       sum+=this.speciesNodes.get(i).second;
                   }
                   pw.println("Species Lineage\t\t Frequency");
                   for (int i =0; i<this.speciesNodes.size(); i++){
                        if(this.speciesNodes.get(i).second/(double)sum > threshold_speciation_support)
                            pw.println(this.speciesNodes.get(i).first +" \t--\t"+ String.format("%.4f",this.speciesNodes.get(i).second/(double)sum) +"  ("+ this.speciesNodes.get(i).second +"/"+sum+")");
                   }
                       
                }
            }
        }
        
      class species_edge { //Delcare variables below

            String name;      // From species edge x, to species edge y
            List<Double> times = new ArrayList<Double>();   // Left child descendent leaves
            
            public species_edge(String fr_to_name, List<Double> ts){
                name = fr_to_name;
                times=ts;
            } 
            
            public String getTransferName(){
                return name;
            }
      }
        public static List<vertex_stats> addItemToList(List<vertex_stats> itemList, vertex_stats item)
        {
            int i=0;
            for (i=0; i < itemList.size(); i++)
            {
                if((item.get_LC_leaves().contains(itemList.get(i).get_LC_leaves()) && item.get_RC_leaves().contains(itemList.get(i).get_RC_leaves())) ||
                        (item.get_LC_leaves().contains(itemList.get(i).get_RC_leaves()) && item.get_RC_leaves().contains(itemList.get(i).get_LC_leaves())))
                    break;
            }
            if(i != itemList.size())
            {
                itemList.get(i).add_to_vertex_stats(item.get_leaves(), item.get_vertex_freq(), item.get_dup_freq(), item.get_trans_freq(), item.get_spec_freq(), item.get_fromTo(), item.get_Sp_nodes().get(0).first);
            }else
            {   
                itemList.add(item);
            }
            return(itemList);
        }
}


